#include <iostream>
using std::cout;
using std::endl;
void main()
{
	unsigned short number = 16387U;		// 16387(10) == 4003(16) == 0100 0000 0000 0011 (2)
	unsigned short result = number<<2;	//							0000 0000 0000 1100 (2) = 12(10)
	cout<<result<<endl;
	result=number>>2;					//							0001 0000 0000 0000 (2) = 2^12(10)
	//只要没有舍弃位，向左移动n位就相当于把该数乘以2^n,同样，向右移动n位就相当于把该数除以2^n。
	//在没有溢出的情况下，向左（向右）移位是与相乘（相除）等价的

	//移位运算符与插入和提取运算符容易搞混。要输出number向左移2位的结果，需要按如下的来写
	cout<< (number<<2) ;

	//移位运算可以用在有符号和无符号的整型数。但右移带符号数的操作随系统的不同而不同，这取决于编译器的实现。
	//有时，向右移会在左边空出来的位上填充0，有时，符号位向右移动，会在左边空出来的位上补1。
	//移符号位的原因是为了保持向右移位和除法运算的一致性。下面用char类型的变量说明
	signed char va = -104;		//  10011000 (2) == -104 (10)
	va>>=2;						//  11100110 (2) == -26  (10)
	// -26 == -104 / 4

	//对于不带符号的整数类型的操作，符号位不移动，在左边空出来的位上填充0

	//所以，应该使用不带符号的整数，以确保避免高阶位的移动。


}