// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include "SSANAgent.h"
#include "config.h"
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TSimpleServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TBufferTransports.h>
#include <iostream>
#include <sstream>
#include <curl/curl.h>
#include <pthread.h>
#include <fcntl.h>

using namespace std;
using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;

using boost::shared_ptr;

using namespace  ::ssan;

class SSANAgentHandler : virtual public SSANAgentIf {
 public:
  SSANAgentHandler() {
    // Your initialization goes here
  }

  /**
   * A method definition looks like C code. It has a return type, arguments,
   * and optionally a list of exceptions that it may throw. Note that argument
   * lists and exception lists are specified using the exact same syntax as
   * field lists in struct or exception definitions.
   */
  bool ping() {
    // Your implementation goes here
    printf("ping\n");
    return true;
  }

  void run(std::string& _return, const std::string& cmd) 
  {
    ostringstream ss;

    FILE * pp = popen(cmd.c_str(), "r");
    if (pp != NULL)
    {
        char buf[4096];

        while(fgets(buf, sizeof(buf), pp))
        {
            ss << buf;
        }
        
        pclose(pp);
    }
    else
    {
        ss << "Error: No such command " << cmd;
    }

    _return = ss.str();
  }

  /**
   * This method has a oneway modifier. That means the client only makes
   * a request and does not listen for any response at all. Oneway methods
   * must be void.
   */
  void zip() {
    // Your implementation goes here
    printf("zip\n");
  }

};

class ThreadData
{
public :
    ThreadData(const char * command, const char * type) : 
        _command(command), _type(type)
    {}

    string  _command;
    string  _type;
};


static std::list<pthread_t> g_threads;
static volatile int         g_exit = 0;
static char                 g_ip[32];
static char                 g_web[128];
static int                  g_timeout = 10;

static int post_data(const char * url, const char * data)
{
    fprintf(stderr, "Info: post data(%d bytes) to %s\n", strlen(data), url);

    CURL * curl = curl_easy_init();
    if (curl)
    {
        curl_easy_setopt(curl, CURLOPT_URL, url);  
        curl_easy_setopt(curl, CURLOPT_POST, 1);  
        curl_easy_setopt(curl, CURLOPT_POSTFIELDS, data);  
        curl_easy_setopt(curl, CURLOPT_READFUNCTION, NULL);  
        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, NULL);  
        curl_easy_setopt(curl, CURLOPT_NOSIGNAL, 1);  
        curl_easy_setopt(curl, CURLOPT_CONNECTTIMEOUT, 3);  
        curl_easy_setopt(curl, CURLOPT_TIMEOUT, 3);  
        curl_easy_perform(curl);
        curl_easy_cleanup(curl);


        return 0;
    }

    return -1;
}

static void * log_watch_thread(void * param)
{
    ThreadData * data = (ThreadData *)param;
    int size = 1024 - 1, count = 0;
    char * buf;

    if ((buf = new char[size + 1]) == NULL)
    {
        fprintf(stderr, "Error: insufficient memory\n");
        pthread_exit(NULL);
    }

    char url[1024];
    snprintf(url, sizeof(url), "%s?ip=%s&type=%s", g_web, g_ip, data->_type.c_str());
        
    fprintf(stderr, "Info: %s=>%s\n", data->_command.c_str(), url);

    ostringstream ss;

    FILE * pp = popen(data->_command.c_str(), "r");
    if (pp != NULL)
    {
        time_t ts = time(NULL);
        int fd = fileno(pp), flags;

        flags = fcntl(fd, F_GETFL, 0);
        flags |= O_NONBLOCK;
        fcntl(fd, F_SETFL, flags);

        char line[1024];

        while (! g_exit)
        {
            if (fgets(line, sizeof(line), pp))
            {
                int len = strlen(line);
                if (len > 0 && len > size - count)
                {
                    post_data(url, buf);
                    count = 0;
                    buf[0] = 0;
                
                    ts = time(NULL);
                }
                
                fprintf(stderr, "Info: reading %d bytes\n", len);
                strncpy(buf + count, line, size - count);
                count += len;
            }
            else
            {
                time_t now = time(NULL);
                if (now - ts > g_timeout && count > 0)
                {
                    post_data(url, buf);
                    count = 0;
                    buf[0] = 0;
                
                    ts = time(NULL);
                }

                sleep(5);
            }
        }

        
        pclose(pp);
    }

    fprintf(stderr, "Info: thread exit\n");

    pthread_exit(NULL);
}

static void init_log_watch()
{
    pthread_t thread;
    int res;
    
    res = pthread_create(& thread, NULL, log_watch_thread, 
        (void *)new ThreadData("tail -f /var/log/messages", "dmsg"));
    if (res)
    {
        fprintf(stderr, "Error: pthread_create %d\n", res);
        exit(-1);
    }
    else
    {
        g_threads.push_back(thread);
    }
    
    res = pthread_create(& thread, NULL, log_watch_thread, 
        (void *)new ThreadData("tail -f /var/log/httpd/access_log", "ssan"));
    if (res)
    {
        fprintf(stderr, "Error: pthread_create %d\n", res);
        exit(-1);
    }
    else
    {
        g_threads.push_back(thread);
    }
}

static void wait_log_watch()
{
    g_exit = 1;

    for (std::list<pthread_t>::iterator it = g_threads.begin(); it != g_threads.end(); it++)
    {
        pthread_join(* it, NULL);
    }
}


int main(int argc, char **argv) 
{
    conf_handler conf = conf_file_open("ssan.conf");
    if (conf)
    {
        conf_file_get(conf, "ip", g_ip, sizeof(g_ip));
        conf_file_get(conf, "interface", g_web, sizeof(g_web));
        conf_file_close(conf);

        fprintf(stderr, "Info: ip=%s\n", g_ip);
        fprintf(stderr, "Info: interface=%s\n", g_web);
    }

    int port = 9090;
    shared_ptr<SSANAgentHandler> handler(new SSANAgentHandler());
    shared_ptr<TProcessor> processor(new SSANAgentProcessor(handler));
    shared_ptr<TServerTransport> serverTransport(new TServerSocket(port));
    shared_ptr<TTransportFactory> transportFactory(new TBufferedTransportFactory());
    shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());

    init_log_watch();

    TSimpleServer server(processor, serverTransport, transportFactory, protocolFactory);
    server.serve();

    wait_log_watch();

    return 0;
}

